package conserve.proto;

// Used in various messages to track when the metadata was written and by whom.
message Stamp {
    optional int64 unixtime = 1;
    optional string hostname = 2;
    optional string software_version = 3;
}

// One ArchiveHeader in '/CONSERVE-ARCHIVE' in the root of the archive directory.
message ArchiveHead {
    // Literal "conserve archive"
    required string magic = 1;

    // Clients must understand these features to safely read the archive.
    repeated string required_read_flags = 2;

    // Clients must understand these features to safely write the archive.
    repeated string required_write_flags = 3;

    optional Stamp stamp = 4;
}

enum FileType {
    UNKNOWN = 0;
    REGULAR = 1;
    DIRECTORY = 2;
    SYMLINK = 3;
}


// One BandHead in 'BAND-HEAD' in each band directory.
message BandHead {
    // Should correspond to the on-disk band number, eg "0000".
    optional string band_number = 1;

    optional Stamp stamp = 2;
}


// One BandTail in 'BAND-TAIL' for complete bands only.
message BandTail {
    optional string band_number = 1;

    optional Stamp stamp = 2;

    optional int32 block_count = 4;

    // TODO(mbp): Maybe, store lengths and hashes of all index blocks?
    // But that may make it slow to finish the band, if they need to
    // all be re-read, and there's no guarantee they weren't corrupted while
    // the band was being written...
}


// One FileIndex per file version.
message FileIndex {
    // File path from backup root (generally utf-8).  (Required for all current files.)
    optional bytes path = 1;

    optional FileType file_type = 2;

    // SHA-1 hash of the contents of the file, as plain bytes (not hex).
    optional bytes data_sha1 = 3;

    // Length of the file body.
    optional int64 data_length = 4;

    // Offset of the body within the block data file.
    optional int64 data_offset = 5;

    // TODO(mbp): mtime, owner, group, perms, ...
}


// One BlockIndex in 'a000000' for each data block.
message BlockIndex {
    // Information about all files in the block, in filename order.
    repeated FileIndex file = 1;

    // Hash and length of the whole data file.
    optional bytes data_sha1 = 2;
    optional int64 data_length = 3;

    optional Stamp stamp = 4;
}

// vim: et sw=4
