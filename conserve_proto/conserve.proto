package conserve.proto;

// Used in various messages to track when the metadata was written and by whom,
// for the sake of tracking timing, audit trail, and identifying or working
// around software bugs.
message Stamp {
    optional int64 unixtime = 1;
    optional string hostname = 2;
    optional string software_version = 3;
}

// One ArchiveHeader in '/CONSERVE' in the root of the archive directory.
message ArchiveHead {
    // Literal "conserve archive"
    required string magic = 1;

    // Clients must understand these features to safely read the archive.
    repeated string required_read_flags = 2;

    // Clients must understand these features to safely write the archive.
    repeated string required_write_flags = 3;

    optional Stamp stamp = 4;
}

enum FileType {
    REGULAR = 0;
    UNKNOWN = 1;
    DIRECTORY = 2;
    SYMLINK = 3;
}


enum Compression {
    NONE = 0;
    GZIP = 1;
    BZIP2 = 2;
};


// One BandHead in 'BANDHEAD' in each band directory.
message BandHead {
    // Should correspond to the on-disk band number, eg "0000".
    optional string band_number = 1;

    optional Stamp stamp = 2;
}


// One BandTail in 'BANDTAIL' for complete bands only.
message BandTail {
    optional string band_number = 1;

    optional Stamp stamp = 2;

    optional int32 block_count = 4;

    // TODO(mbp): Maybe, store lengths and hashes of all index blocks?  But
    // that may make it slow to finish the band, if they need to all be
    // re-read, and there's no guarantee they weren't corrupted while the
    // band was being written. Maybe store them per N blocks.
}


// A file path, as a sequence of components.  To make a unix relative path
// they can joined up with slashes.

message Path {
    // This is generally utf-8, but stored as bytes
    // so it can cope with anomalously named files.
    repeated bytes part = 1;
}


// One FileIndex per file version.
message FileIndex {
    // Relative path from source directory.  Required for all current files.
    optional Path path = 1;

    // Type of file; unspecified means a plain file.
    optional FileType file_type = 2;

    // SHA-1 hash of the contents of the file, as plain bytes (not hex).
    optional bytes data_sha1 = 3;

    // Length of the (uncompressed) file body.
    optional int64 data_length = 4;

    // TODO(mbp): mtime, owner, group, perms, ...
}


// One BlockIndex in 'a000000' for each data block.
message BlockIndex {
    // Information about all files in the block, in filename order.
    repeated FileIndex file = 1;

    // Hash and length of the whole data file.
    optional bytes data_sha1 = 2;
    optional int64 data_length = 3;

    optional Stamp stamp = 4;

    optional Compression compression = 5;

    // TODO(mbp): Specify whether/how it's compressed?
}

// vim: et sw=4
